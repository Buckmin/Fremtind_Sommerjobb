import React, { useRef, useCallback, useLayoutEffect, useEffect, useReducer } from 'react';
import { breakpoints } from '@fremtind/jkl-core';

function useAnimatedHeight(isOpen) {
  var raf1 = useRef();
  var raf2 = useRef();
  var elementRef = useRef(null);
  var firstRender = useRef(true);

  function handleTransitionEnd() {
    var element = getElement(elementRef);

    if (element) {
      element.removeAttribute("style");
    }
  }

  var runAnimation = useCallback(function () {
    if (firstRender.current) {
      return; // Do not play animation on first render
    }

    var element = getElement(elementRef);

    if (element) {
      element.style.display = "block";
      element.style.overflow = "hidden";

      if (isOpen) {
        element.style.height = "0";
        element.style.height = "".concat(element.scrollHeight, "px");
      } else {
        element.style.height = "".concat(element.scrollHeight, "px");
        raf1.current = requestAnimationFrame(function () {
          raf2.current = requestAnimationFrame(function () {
            element.style.height = "".concat(0, "px");
          });
        });
      }
    }
  }, [isOpen]);
  useLayoutEffect(function () {
    runAnimation();
  }, [isOpen, runAnimation]);
  useEffect(function () {
    var element = getElement(elementRef);

    if (element) {
      element.addEventListener("transitionend", handleTransitionEnd);
    }

    return function () {
      if (element) {
        element.removeEventListener("transitionend", handleTransitionEnd);
      }
    };
  }, [isOpen]);
  useEffect(function () {
    var r1 = raf1.current;
    var r2 = raf2.current;
    firstRender.current = false;
    return function () {
      r1 && cancelAnimationFrame(r1);
      r2 && cancelAnimationFrame(r2);
    };
  }, [raf1, raf2]);
  return [elementRef, runAnimation];
}

function getElement(elementRef) {
  // Workaround to handle custom elements from NRK Core components until this lands:
  // https://github.com/nrkno/custom-element-to-react/pull/17
  return elementRef.current && (elementRef.current.el || elementRef.current);
}

function useClickOutside(ref, fn) {
  function handleClickOutside(event) {
    if (ref && ref.current && !ref.current.contains(event.target)) {
      fn();
    }
  }

  React.useEffect(function () {
    if (ref) {
      document && document.addEventListener("click", handleClickOutside);
    }

    return function () {
      if (ref) {
        document && document.removeEventListener("click", handleClickOutside);
      }
    };
  });
}

function useFocusOutside(ref, fn) {
  function handleFocusOutside(event) {
    if (ref && ref.current && !ref.current.contains(event.target)) {
      fn();
    }
  }

  React.useEffect(function () {
    if (ref) {
      // focusin event not yet typed. See https://github.com/microsoft/TypeScript/issues/30716
      // @ts-ignore
      document && document.addEventListener("focusin", handleFocusOutside);
    }

    return function () {
      if (ref) {
        // focusin event not yet typed. See https://github.com/microsoft/TypeScript/issues/30716
        // @ts-ignore
        document && document.removeEventListener("focusin", handleFocusOutside);
      }
    };
  });
}

function useKeyListener(ref, keys, fn) {
  if (typeof keys === "string") {
    keys = [keys];
  }

  function handleKeyDown(event) {
    if (keys && !keys.includes(event.key)) {
      return;
    }

    fn(event);
  }

  useEffect(function () {
    var element = ref && ref.current;

    if (element) {
      element.addEventListener("keydown", handleKeyDown);
    }

    return function () {
      if (element) {
        element.removeEventListener("keydown", handleKeyDown);
      }
    };
  });
}

var hasWindowWithMutationObserver = function hasWindowWithMutationObserver() {
  return typeof window !== "undefined" && typeof MutationObserver !== "undefined";
};

var useMutationObserver = function useMutationObserver(targetRef, onObservation, config) {
  var observerRef = useRef(null);
  useEffect(function () {
    var observer = observerRef.current;

    if (hasWindowWithMutationObserver()) {
      var target = targetRef.current;

      if (observer) {
        observer.disconnect();
      }

      observer = new MutationObserver(onObservation);

      if (target) {
        observer.observe(target, config);
      }
    }

    return function () {
      if (hasWindowWithMutationObserver() && observer) {
        observer.disconnect();
      }
    };
  }, [targetRef, onObservation, config]);
};

var hasWindowWithIntersectionObserver = function hasWindowWithIntersectionObserver() {
  return typeof window !== "undefined" && typeof IntersectionObserver !== "undefined";
};

var useIntersectionObserver = function useIntersectionObserver(targetRef, onIntersect, fallback, options) {
  var observerRef = useRef(null);
  useEffect(function () {
    var observer = observerRef.current;

    if (hasWindowWithIntersectionObserver()) {
      var target = targetRef.current;

      if (observer) {
        observer.disconnect();
      }

      observer = new IntersectionObserver(onIntersect, options);

      if (target) {
        observer.observe(target);
      }
    } else {
      fallback();
    }

    return function () {
      if (hasWindowWithIntersectionObserver() && observer) {
        observer.disconnect();
      }
    };
  }, [targetRef, onIntersect, fallback, options]);
};

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys(Object(source), true).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

function _slicedToArray(arr, i) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
}

function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}

function _iterableToArrayLimit(arr, i) {
  if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _e = undefined;

  try {
    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

  return arr2;
}

function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

var ActionTypes;

(function (ActionTypes) {
  ActionTypes["resized"] = "WINDOW_RESIZED";
})(ActionTypes || (ActionTypes = {}));

var actionTypes = {
  resized: ActionTypes.resized
};

var setDeviceSize = function setDeviceSize(width, height) {
  return {
    isSmallDevice: width < breakpoints.small,
    isMediumDevice: width > breakpoints.small && width < breakpoints.medium,
    isLargeDevice: width > breakpoints.medium && width < breakpoints.large,
    isXlDevice: width > breakpoints.large,
    isPortrait: height >= width,
    isLandscape: height < width,
    inner: {
      height: height,
      width: width
    }
  };
};

var initialState = {
  isSmallDevice: false,
  isMediumDevice: false,
  isLargeDevice: false,
  isXlDevice: false,
  isLandscape: false,
  isPortrait: false,
  inner: {
    height: 0,
    width: 0
  }
};
var init = function init() {
  var width = typeof window !== "undefined" ? window.innerWidth : 0;
  var height = typeof window !== "undefined" ? window.innerHeight : 0;
  return setDeviceSize(width, height);
};
var reducer = function reducer(state, _ref) {
  var type = _ref.type,
      width = _ref.width,
      height = _ref.height;

  switch (type) {
    case actionTypes.resized:
      return _objectSpread2(_objectSpread2({}, state), setDeviceSize(width, height));
  }
};

var useScreen = function useScreen() {
  var _useReducer = useReducer(reducer, initialState, init),
      _useReducer2 = _slicedToArray(_useReducer, 2),
      device = _useReducer2[0],
      deviceDispatch = _useReducer2[1];

  var handleScreenChange = function handleScreenChange() {
    return requestAnimationFrame(function () {
      return deviceDispatch({
        type: actionTypes.resized,
        width: window.innerWidth,
        height: window.innerHeight
      });
    });
  };

  useEffect(function () {
    if (typeof window !== "undefined") {
      window.addEventListener("resize", handleScreenChange);
    }

    return function () {
      if (typeof window !== "undefined") {
        window.removeEventListener("resize", handleScreenChange);
      }
    };
  }, []);
  return _objectSpread2({}, device);
};

var useScrollIntoView = function useScrollIntoView(_ref) {
  var ref = _ref.ref,
      _ref$timeout = _ref.timeout,
      timeout = _ref$timeout === void 0 ? 0 : _ref$timeout,
      _ref$autoScroll = _ref.autoScroll,
      autoScroll = _ref$autoScroll === void 0 ? true : _ref$autoScroll,
      _ref$options = _ref.options,
      options = _ref$options === void 0 ? {
    behavior: "smooth"
  } : _ref$options;

  var scrollIntoView = function scrollIntoView() {
    if (ref && ref.current) {
      ref.current.scrollIntoView(options);
    }
  };

  useEffect(function () {
    if (!autoScroll) {
      return;
    }

    var scrollFn = setTimeout(scrollIntoView, timeout);
    return function () {
      return clearTimeout(scrollFn);
    };
  }, [ref, timeout, autoScroll]);
  return [scrollIntoView];
};

export { initialState as initialScreenState, useAnimatedHeight, useClickOutside, useFocusOutside, useIntersectionObserver, useKeyListener, useMutationObserver, useScreen, useScrollIntoView };
