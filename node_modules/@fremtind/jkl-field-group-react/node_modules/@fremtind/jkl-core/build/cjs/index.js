'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var React = _interopDefault(require('react'));

var mousenavigation = false;

function handleMouseDown() {
  if (!mousenavigation) {
    mousenavigation = true;
    var htmlElement = document.querySelector("html");
    htmlElement && htmlElement.setAttribute("data-mousenavigation", "true");
    document.removeEventListener("mousedown", handleMouseDown);
    document.addEventListener("keydown", handleKeydown);
  }
}

function handleKeydown(event) {
  if (event.key === "Tab") {
    if (mousenavigation) {
      mousenavigation = false;
      var htmlElement = document.querySelector("html");
      htmlElement && htmlElement.removeAttribute("data-mousenavigation");
      document.removeEventListener("keydown", handleKeydown);
      document.addEventListener("mousedown", handleMouseDown);
    }
  }
}

function initTabListener() {
  if (typeof document !== "undefined") {
    document.addEventListener("mousedown", handleMouseDown);
  }
}

function getValuePair(item) {
  return typeof item === "string" ? {
    value: item,
    label: item
  } : item;
}

var breakpoints = {
  small: 768,
  medium: 992,
  large: 1200,
  xl: 1600
};

var ScreenReaderOnly = function ScreenReaderOnly(_ref) {
  var children = _ref.children,
      showOnFocus = _ref.showOnFocus;
  return /*#__PURE__*/React.createElement("span", {
    className: "jkl-sr-only ".concat(showOnFocus ? "jkl-sr-only--focusable" : "")
  }, children);
};

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

function _objectWithoutProperties(source, excluded) {
  if (source == null) return {};

  var target = _objectWithoutPropertiesLoose(source, excluded);

  var key, i;

  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }

  return target;
}

function createCommonjsModule(fn, module) {
	return module = { exports: {} }, fn(module, module.exports), module.exports;
}

var classnames = createCommonjsModule(function (module) {
/*!
  Copyright (c) 2017 Jed Watson.
  Licensed under the MIT License (MIT), see
  http://jedwatson.github.io/classnames
*/
/* global define */

(function () {

	var hasOwn = {}.hasOwnProperty;

	function classNames () {
		var classes = [];

		for (var i = 0; i < arguments.length; i++) {
			var arg = arguments[i];
			if (!arg) continue;

			var argType = typeof arg;

			if (argType === 'string' || argType === 'number') {
				classes.push(arg);
			} else if (Array.isArray(arg) && arg.length) {
				var inner = classNames.apply(null, arg);
				if (inner) {
					classes.push(inner);
				}
			} else if (argType === 'object') {
				for (var key in arg) {
					if (hasOwn.call(arg, key) && arg[key]) {
						classes.push(key);
					}
				}
			}
		}

		return classes.join(' ');
	}

	if ( module.exports) {
		classNames.default = classNames;
		module.exports = classNames;
	} else {
		window.classNames = classNames;
	}
}());
});
var classnames_1 = classnames.named;

var Label = function Label(_ref) {
  var _classNames;

  var _ref$variant = _ref.variant,
      variant = _ref$variant === void 0 ? "medium" : _ref$variant,
      forceCompact = _ref.forceCompact,
      srOnly = _ref.srOnly,
      children = _ref.children,
      standAlone = _ref.standAlone,
      htmlFor = _ref.htmlFor,
      _ref$className = _ref.className,
      className = _ref$className === void 0 ? "" : _ref$className;
  var labelClassNames = classnames("jkl-label", className, (_classNames = {}, _defineProperty(_classNames, "jkl-label--".concat(variant), variant), _defineProperty(_classNames, "jkl-label--compact", forceCompact), _defineProperty(_classNames, "jkl-label--sr-only", srOnly), _classNames));
  var C = standAlone ? "label" : "span";

  if (!standAlone && htmlFor) {
    htmlFor = undefined;

    if (process.env.NODE_ENV !== "production") {
      console.warn("WARNING: The standard Label component renders as a <span> element, which does not take a htmlFor prop. If you want the Label to belong to a specific input, use the standAlone prop, which renders as a <label> element instead. In most cases the Label component should not be used directly, as it is part of all our input components.");
    }
  }

  return /*#__PURE__*/React.createElement(C, {
    className: labelClassNames,
    htmlFor: htmlFor
  }, children);
};

var Link = function Link(_ref) {
  var _ref$negative = _ref.negative,
      negative = _ref$negative === void 0 ? false : _ref$negative,
      _ref$external = _ref.external,
      external = _ref$external === void 0 ? false : _ref$external,
      _ref$className = _ref.className,
      className = _ref$className === void 0 ? "" : _ref$className,
      children = _ref.children,
      rest = _objectWithoutProperties(_ref, ["negative", "external", "className", "children"]);

  return /*#__PURE__*/React.createElement("a", _extends({
    className: classnames("jkl-link", className, {
      "jkl-link--negative": negative,
      "jkl-link--external": external
    })
  }, rest), children);
};

var SupportLabel = function SupportLabel(_ref) {
  var id = _ref.id,
      helpLabel = _ref.helpLabel,
      errorLabel = _ref.errorLabel,
      forceCompact = _ref.forceCompact,
      className = _ref.className,
      srOnly = _ref.srOnly,
      inverted = _ref.inverted;
  var componentClassName = classnames("jkl-form-support-label", className, {
    "jkl-form-support-label--compact": forceCompact,
    "jkl-form-support-label--error": errorLabel,
    "jkl-form-support-label--help": !errorLabel,
    "jkl-form-support-label--sr-only": srOnly,
    "jkl-form-support-label--inverted": inverted
  });

  if (errorLabel || helpLabel) {
    return /*#__PURE__*/React.createElement("span", {
      id: id,
      className: componentClassName
    }, errorLabel || helpLabel);
  }

  return null;
};

exports.Label = Label;
exports.Link = Link;
exports.ScreenReaderOnly = ScreenReaderOnly;
exports.SupportLabel = SupportLabel;
exports.breakpoints = breakpoints;
exports.getValuePair = getValuePair;
exports.initTabListener = initTabListener;
