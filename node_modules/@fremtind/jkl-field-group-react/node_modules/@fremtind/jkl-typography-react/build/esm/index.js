import React from 'react';

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

function _objectWithoutProperties(source, excluded) {
  if (source == null) return {};

  var target = _objectWithoutPropertiesLoose(source, excluded);

  var key, i;

  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }

  return target;
}

function makeTypographyComponent(variant, textStyle, modifier) {
  return function typography(_ref) {
    var children = _ref.children,
        className = _ref.className,
        rest = _objectWithoutProperties(_ref, ["children", "className"]);

    var tagName = (modifier || variant).replace(/^\w/, function (c) {
      return c.toUpperCase();
    });

    if (process.env.NODE_ENV === "development") {
      console.warn("ATTENTION! The typographic components in jkl-core, like \"".concat(tagName, "\", are deprecated. Please stop using them and start using typographic CSS classes or the jkl-text-style Sass mixin instead. Refer to the documentation for more info."));
    }

    var Element = variant;
    return /*#__PURE__*/React.createElement(Element, _extends({
      className: "".concat(textStyle, " ").concat(className || "")
    }, rest), children);
  };
}

var H1 = makeTypographyComponent("h1", "jkl-title-large");
var H2 = makeTypographyComponent("h2", "jkl-title-small");
var H3 = makeTypographyComponent("h3", "jkl-heading-large");
var H4 = makeTypographyComponent("h4", "jkl-heading-medium");
var H5 = makeTypographyComponent("h5", "jkl-heading-small");
var Lead = makeTypographyComponent("p", "jkl-lead", "lead");
var Body = makeTypographyComponent("p", "jkl-body", "body");
var Small = makeTypographyComponent("p", "jkl-small", "small");
var Micro = makeTypographyComponent("p", "jkl-micro", "micro");

function createCommonjsModule(fn, module) {
	return module = { exports: {} }, fn(module, module.exports), module.exports;
}

var classnames = createCommonjsModule(function (module) {
/*!
  Copyright (c) 2017 Jed Watson.
  Licensed under the MIT License (MIT), see
  http://jedwatson.github.io/classnames
*/
/* global define */

(function () {

	var hasOwn = {}.hasOwnProperty;

	function classNames () {
		var classes = [];

		for (var i = 0; i < arguments.length; i++) {
			var arg = arguments[i];
			if (!arg) continue;

			var argType = typeof arg;

			if (argType === 'string' || argType === 'number') {
				classes.push(arg);
			} else if (Array.isArray(arg) && arg.length) {
				var inner = classNames.apply(null, arg);
				if (inner) {
					classes.push(inner);
				}
			} else if (argType === 'object') {
				for (var key in arg) {
					if (hasOwn.call(arg, key) && arg[key]) {
						classes.push(key);
					}
				}
			}
		}

		return classes.join(' ');
	}

	if ( module.exports) {
		classNames.default = classNames;
		module.exports = classNames;
	} else {
		window.classNames = classNames;
	}
}());
});
var classnames_1 = classnames.named;

var warningHasBeenShown = false;
var Link = function Link(_ref) {
  var _ref$negative = _ref.negative,
      negative = _ref$negative === void 0 ? false : _ref$negative,
      _ref$external = _ref.external,
      external = _ref$external === void 0 ? false : _ref$external,
      children = _ref.children,
      _ref$className = _ref.className,
      className = _ref$className === void 0 ? "" : _ref$className,
      rest = _objectWithoutProperties(_ref, ["negative", "external", "children", "className"]);

  if (process.env.NODE_ENV !== "production" && !warningHasBeenShown) {
    console.warn("WARNING: This version of the Link component is deprecated! Please use the Link component found in @fremtind/jkl-core instead");
    warningHasBeenShown = true;
  }

  return /*#__PURE__*/React.createElement("a", _extends({
    className: classnames("jkl-link", className, {
      "jkl-link--negative": negative,
      "jkl-link--external": external
    })
  }, rest), children);
};

var warningHasBeenShown$1 = false;
var SupportLabel = function SupportLabel(_ref) {
  var id = _ref.id,
      helpLabel = _ref.helpLabel,
      errorLabel = _ref.errorLabel,
      forceCompact = _ref.forceCompact,
      className = _ref.className,
      srOnly = _ref.srOnly,
      inverted = _ref.inverted;
  var componentClassName = classnames("jkl-form-support-label", className, {
    "jkl-form-support-label--compact": forceCompact,
    "jkl-form-support-label--error": errorLabel,
    "jkl-form-support-label--help": !errorLabel,
    "jkl-form-support-label--sr-only": srOnly,
    "jkl-form-support-label--inverted": inverted
  });

  if (process.env.NODE_ENV !== "production" && !warningHasBeenShown$1) {
    console.warn("WARNING: This version of the SupportLabel component is deprecated! Please use the SupportLabel component found in @fremtind/jkl-core instead");
    warningHasBeenShown$1 = true;
  }

  if (errorLabel || helpLabel) {
    return /*#__PURE__*/React.createElement("span", {
      id: id,
      className: componentClassName
    }, errorLabel || helpLabel);
  }

  return null;
};

var warningHasBeenShown$2 = false;
function Label(_ref) {
  var _classNames;

  var _ref$variant = _ref.variant,
      variant = _ref$variant === void 0 ? "medium" : _ref$variant,
      forceCompact = _ref.forceCompact,
      srOnly = _ref.srOnly,
      children = _ref.children,
      standAlone = _ref.standAlone,
      htmlFor = _ref.htmlFor;
  var className = classnames("jkl-label", (_classNames = {}, _defineProperty(_classNames, "jkl-label--".concat(variant), variant), _defineProperty(_classNames, "jkl-label--compact", forceCompact), _defineProperty(_classNames, "jkl-label--sr-only", srOnly), _classNames));
  var C = standAlone ? "label" : "span";

  if (!standAlone && htmlFor) {
    htmlFor = undefined;

    if (process.env.NODE_ENV !== "production") {
      console.warn("WARNING: The standard Label component renders as a <span> element, which does not take a htmlFor prop. If you want the Label to belong to a specific input, use the standAlone prop, which renders as a <label> element instead. In most cases the Label component should not be used directly, as it is part of all our input components.");
    }
  }

  if (process.env.NODE_ENV !== "production" && !warningHasBeenShown$2) {
    console.warn("WARNING: This version of the Label component is deprecated! Please use the Label component found in @fremtind/jkl-core instead");
    warningHasBeenShown$2 = true;
  }

  return /*#__PURE__*/React.createElement(C, {
    className: className,
    htmlFor: htmlFor
  }, children);
}

export { Body, H1, H2, H3, H4, H5, Label, Lead, Link, Micro, Small, SupportLabel };
