'use strict';

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) _setPrototypeOf(subClass, superClass);
}

function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

function isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

function _construct(Parent, args, Class) {
  if (isNativeReflectConstruct()) {
    _construct = Reflect.construct;
  } else {
    _construct = function _construct(Parent, args, Class) {
      var a = [null];
      a.push.apply(a, args);
      var Constructor = Function.bind.apply(Parent, a);
      var instance = new Constructor();
      if (Class) _setPrototypeOf(instance, Class.prototype);
      return instance;
    };
  }

  return _construct.apply(null, arguments);
}

function _isNativeFunction(fn) {
  return Function.toString.call(fn).indexOf("[native code]") !== -1;
}

function _wrapNativeSuper(Class) {
  var _cache = typeof Map === "function" ? new Map() : undefined;

  _wrapNativeSuper = function _wrapNativeSuper(Class) {
    if (Class === null || !_isNativeFunction(Class)) return Class;

    if (typeof Class !== "function") {
      throw new TypeError("Super expression must either be null or a function");
    }

    if (typeof _cache !== "undefined") {
      if (_cache.has(Class)) return _cache.get(Class);

      _cache.set(Class, Wrapper);
    }

    function Wrapper() {
      return _construct(Class, arguments, _getPrototypeOf(this).constructor);
    }

    Wrapper.prototype = Object.create(Class.prototype, {
      constructor: {
        value: Wrapper,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    return _setPrototypeOf(Wrapper, Class);
  };

  return _wrapNativeSuper(Class);
}

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function _possibleConstructorReturn(self, call) {
  if (call && (typeof call === "object" || typeof call === "function")) {
    return call;
  }

  return _assertThisInitialized(self);
}

var IS_BROWSER = typeof window !== 'undefined';
var IS_ANDROID = IS_BROWSER && /(android)/i.test(navigator.userAgent); // Bad, but needed

var IS_IOS = IS_BROWSER && /iPad|iPhone|iPod/.test(String(navigator.platform)); // Mock HTMLElement for Node

if (!IS_BROWSER && !global.HTMLElement) {
  global.HTMLElement =
  /*#__PURE__*/
  function () {
    function _class() {
      _classCallCheck(this, _class);
    }

    return _class;
  }();
}
/**
* closest
* @param {Element} element Element to traverse up from
* @param {String} selector A selector to search for matching parents or element itself
* @return {Element|null}  Element which is the closest ancestor matching selector
*/

var closest = function () {
  var proto = typeof window === 'undefined' ? {} : window.Element.prototype;
  var match = proto.matches || proto.msMatchesSelector || proto.webkitMatchesSelector;
  return proto.closest ? function (el, css) {
    return el.closest(css);
  } : function (el, css) {
    // IE jumps to shadow SVG DOM on clicking an SVG defined by <use>.
    // If so, jump back to <use> element and traverse real DOM
    if (el.correspondingUseElement) el = el.correspondingUseElement;

    for (; el; el = el.parentElement) {
      if (match.call(el, css)) return el;
    }

    return null;
  };
}();
/**
* dispatchEvent - with infinite loop prevention
* @param {Element} elem The target object
* @param {String} name The source object(s)
* @param {Object} detail Detail object (bubbles and cancelable is set to true)
* @return {Boolean} Whether the event was canceled
*/

function dispatchEvent(element, name) {
  var detail = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  var ignore = "prevent_recursive_dispatch_maximum_callstack".concat(name);
  var event;
  if (element[ignore]) return true; // We are already processing this event, so skip sending a new one
  else element[ignore] = true; // Add name to dispatching ignore

  if (typeof window.CustomEvent === 'function') {
    event = new window.CustomEvent(name, {
      bubbles: true,
      cancelable: true,
      detail: detail
    });
  } else {
    event = document.createEvent('CustomEvent');
    event.initCustomEvent(name, true, true, detail);
  } // IE reports incorrect event.defaultPrevented
  // but correct return value on element.dispatchEvent


  var result = element.dispatchEvent(event);
  element[ignore] = null; // Remove name from dispatching ignore

  return result; // Follow W3C standard for return value
}
/**
* getUUID
* @return {String} A generated unique ID
*/

function getUUID() {
  return Date.now().toString(36) + Math.random().toString(36).slice(2, 5);
}
/**
 * toggleAttribute (Ponyfill for IE and Edge, fixes #299)
 * @link https://developer.mozilla.org/en-US/docs/Web/API/Element/toggleAttribute
 * @param {Element} el  Single DOM Element
 * @param {String} name The name of the attribute to be toggled
 * @param {Boolean} force Force attribute to be added or removed regardless of previous state
 */

function toggleAttribute(el, name) {
  var force = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : !this.hasAttribute(name);
  if (!force === el.hasAttribute(name)) el[force ? 'setAttribute' : 'removeAttribute'](name, '');
  return force;
}

var CoreToggle =
/*#__PURE__*/
function (_HTMLElement) {
  _inherits(CoreToggle, _HTMLElement);

  function CoreToggle() {
    _classCallCheck(this, CoreToggle);

    return _possibleConstructorReturn(this, _getPrototypeOf(CoreToggle).apply(this, arguments));
  }

  _createClass(CoreToggle, [{
    key: "connectedCallback",
    value: function connectedCallback() {
      if (IS_IOS) document.documentElement.style.cursor = 'pointer'; // Fix iOS events for closing popups (https://stackoverflow.com/a/16006333/8819615)

      if (!IS_ANDROID) this.setAttribute('aria-labelledby', this.button.id = this.button.id || getUUID()); // Andriod reads only label instead of content

      this.value = this.button.textContent; // Set up aria-label

      this.setAttribute('role', 'group'); // Help Edge

      this.button.setAttribute('aria-expanded', this._open = !this.hidden);
      this.button.setAttribute('aria-controls', this.id = this.id || getUUID());
      document.addEventListener('keydown', this, true); // Use capture to enable checking defaultPrevented (from ESC key) in parents

      document.addEventListener('click', this);
    }
  }, {
    key: "disconnectedCallback",
    value: function disconnectedCallback() {
      this._button = null;
      document.removeEventListener('keydown', this, true);
      document.removeEventListener('click', this);
    }
  }, {
    key: "attributeChangedCallback",
    value: function attributeChangedCallback() {
      if (this._open === this.hidden) {
        // this._open comparison ensures actual change
        this.button.setAttribute('aria-expanded', this._open = !this.hidden);

        try {
          this.querySelector('[autofocus]').focus();
        } catch (err) {}

        dispatchEvent(this, 'toggle');
      }
    }
  }, {
    key: "handleEvent",
    value: function handleEvent(event) {
      if (event.defaultPrevented) return;

      if (event.type === 'keydown' && event.keyCode === 27) {
        var isButton = event.target.getAttribute && event.target.getAttribute('aria-expanded') === 'true';
        var isHiding = isButton ? event.target === this.button : closest(event.target, this.nodeName) === this;

        if (isHiding) {
          this.hidden = true;
          this.button.focus(); // Move focus back to button

          return event.preventDefault(); // Prevent closing maximized Safari and other coreToggles
        }
      }

      if (event.type === 'click') {
        var btn = closest(event.target, 'a,button');
        if (btn && !btn.hasAttribute('aria-expanded') && closest(event.target, this.nodeName) === this) dispatchEvent(this, 'toggle.select', btn);else if (btn && btn.getAttribute('aria-controls') === this.id) this.hidden = !this.hidden;else if (this.popup && !this.contains(event.target)) this.hidden = true; // Click in content or outside
      }
    }
  }, {
    key: "button",
    get: function get() {
      if (this._button && this._button.getAttribute('for') === this.id) return this._button; // Speed up

      return (this._button = this.id && document.querySelector("[for=\"".concat(this.id, "\"]"))) || this.previousElementSibling;
    } // aria-haspopup triggers forms mode in JAWS, therefore store as custom attr

  }, {
    key: "popup",
    get: function get() {
      return this.getAttribute('popup') === 'true' || this.getAttribute('popup') || this.hasAttribute('popup');
    },
    set: function set(val) {
      this[val === false ? 'removeAttribute' : 'setAttribute']('popup', val);
    } // Must set attribute for IE11

  }, {
    key: "hidden",
    get: function get() {
      return this.hasAttribute('hidden');
    },
    set: function set(val) {
      toggleAttribute(this, 'hidden', val);
    } // Sets this.button aria-label, so visible button text can be augmentet with intension of button
    // Example: Button text: "01.02.2019", aria-label: "01.02.2019, Choose date"
    // Does not updates aria-label if not allready set to something else than this.popup

  }, {
    key: "value",
    get: function get() {
      return this.button.value || this.button.textContent;
    },
    set: function set() {
      var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      if (!this.button || !this.popup.length) return;
      var button = this.button;
      var popup = (button.getAttribute('aria-label') || ",".concat(this.popup)).split(',')[1];
      var label = data.textContent || data || ''; // data can be Element, Object or String

      if (popup === this.popup) {
        button.value = data.value || label;
        button[data.innerHTML ? 'innerHTML' : 'textContent'] = data.innerHTML || label;
        button.setAttribute('aria-label', "".concat(button.textContent, ",").concat(this.popup));
      }
    }
  }], [{
    key: "observedAttributes",
    get: function get() {
      return ['hidden'];
    }
  }]);

  return CoreToggle;
}(_wrapNativeSuper(HTMLElement));

module.exports = CoreToggle;
